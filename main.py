
START = "0"
END = "1"
WALL = "#"
SPACE = "."
def fancy_print(string):
    print(string.replace(START,"SS").replace(END,"FF").replace(WALL, "\u001b[7m  \u001b[0m").replace(SPACE, "  ").replace("*", "**"))


# Given a 2d list of chars, print the solution of the maze as a list of 2-tuples as coordinates

def solveMaze(maze, START, END, WALL, SPACE):
    SIZE_LIMIT = 10000
    counter = 1
    coords = []
    startpoint = (0, 0)
    endpoint = (0, 0)
    for i in range(len(maze)):
        if START in maze[i]:
            startpoint = (i, maze[i].index(START))
            coords = [(i, maze[i].index(START), 0)]
        if END in maze[i]:
            endpoint = (i, maze[i].index(END))
    print("Starts:", startpoint)
    print("Finishes:", endpoint)

    iterations = 0
    still_counting = True
    while True not in [i[0] == endpoint[0] and i[1] == endpoint[1] for i in coords]: # While finish is not in coordinates
        still_counting = False
        templist = []
        for coord in coords:
            for dr, dc in zip((1, -1, 0, 0), (0, 0, 1, -1)):
                if (maze[coord[0] + dr][coord[1] + dc] != WALL and True not in [
                    (i[0] == coord[0] + dr and i[1] == coord[1] + dc) for i in coords] and True not in [
                    (i[0] == coord[0] + dr and i[1] == coord[1] + dc) for i in templist]):
                    still_counting = True
                    templist.append((coord[0] + dr, coord[1] + dc, counter))
        coords += templist
        counter += 1
        iterations += 1
        if not still_counting and (True not in [i[0] == endpoint[0] and i[1] == endpoint[1] for i in coords]):
            print("ERROR: MAZE NOT SOLVABLE!")
            exit()
        if iterations > SIZE_LIMIT:
            print("ERROR: MAZE TO LARGE!")
            exit()
    path = [(endpoint[0], endpoint[1], counter)]

    while path[0][0] != startpoint[0] or path[0][1] != startpoint[1]:
        closest = None
        for coord in coords:
            if (coord[2] < path[0][2] and coord[0] - path[0][0], coord[1] - path[0][1]) in (
            (1, 0), (-1, 0), (0, 1), (0, -1)):
                if (closest == None or coord[2] < closest[2]):
                    closest = coord
        path.insert(0, closest)
    return path



# Loads maze from txt files
# maze/huge.txt, maze/large.txt generated by https://www.dcode.fr/maze-generator
myMaze = [list(i.strip()) for i in open("maze/huge.txt", "r").readlines()]
for row in myMaze:
    fancy_print("".join(row))

mazePath = solveMaze(myMaze, "0", "1", "#", ".")
print("Path Coords:",[i[:2] for i in mazePath])

# Replace path
for coord in mazePath:
    myMaze[coord[0]][coord[1]] = "*"

# Print everything
print("RISE, MY CHILD!")
for row in myMaze:
    fancy_print("".join(row))
print("IT'S ALIVE!!! IT'S ALIVE!!!")
